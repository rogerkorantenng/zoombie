/**
 * #redisapi.ts
 *
 * Code generated by ts-proto. DO NOT EDIT.
 * @packageDocumentation
 */
import type { Empty } from "../../../google/protobuf/empty.js";
/**
 * This key scope determines the key namespacing in Redis storage
 * By default, all keys in Redis are namespaced to an installation
 * Global redis enables apps to persist and access state across subreddit installations
 * Default key format - installation:app:custom-key
 * Global redis key format - global:app:custom-key
 */
export declare enum RedisKeyScope {
    INSTALLATION = 0,
    GLOBAL = 1,
    UNRECOGNIZED = -1
}
export declare enum BitfieldOverflowBehavior {
    BITFIELD_OVERFLOW_BEHAVIOR_UNSPECIFIED = 0,
    BITFIELD_OVERFLOW_BEHAVIOR_WRAP = 1,
    BITFIELD_OVERFLOW_BEHAVIOR_SAT = 2,
    BITFIELD_OVERFLOW_BEHAVIOR_FAIL = 3,
    UNRECOGNIZED = -1
}
export type TransactionResponses = {
    response: TransactionResponse[];
};
export type TransactionResponse = {
    str?: string | undefined;
    nil?: Empty | undefined;
    num?: number | undefined;
    members?: ZMembers | undefined;
    values?: RedisValues | undefined;
    dbl?: number | undefined;
    bool?: boolean | undefined;
};
export type ZRangeRequest = {
    key?: KeyRequest | undefined;
    start: string;
    stop: string;
    byScore: boolean;
    byLex: boolean;
    rev: boolean;
    offset: number;
    count: number;
    scope?: RedisKeyScope | undefined;
};
export type ZRangeByLexRequest = {
    key?: KeyRequest | undefined;
    min: string;
    max: string;
    scope?: RedisKeyScope | undefined;
};
export type ZRangeByScoreRequest = {
    key?: KeyRequest | undefined;
    min: number;
    max: number;
    withScores: boolean;
    scope?: RedisKeyScope | undefined;
};
export type ZRemRequest = {
    key?: KeyRequest | undefined;
    members: string[];
    scope?: RedisKeyScope | undefined;
};
export type ZRemRangeByLexRequest = {
    key?: KeyRequest | undefined;
    min: string;
    max: string;
    scope?: RedisKeyScope | undefined;
};
export type ZRemRangeByRankRequest = {
    key?: KeyRequest | undefined;
    start: number;
    stop: number;
    scope?: RedisKeyScope | undefined;
};
export type ZRemRangeByScoreRequest = {
    key?: KeyRequest | undefined;
    min: number;
    max: number;
    scope?: RedisKeyScope | undefined;
};
export type ZScoreRequest = {
    key?: KeyRequest | undefined;
    member: string;
    scope?: RedisKeyScope | undefined;
};
export type ZRankRequest = {
    key?: KeyRequest | undefined;
    member: string;
    scope?: RedisKeyScope | undefined;
};
export type RedisRankScore = {
    rank: number;
    score: number;
};
export type ZIncrByRequest = {
    key: string;
    member: string;
    value: number;
    /** Optional transaction id */
    transactionId?: TransactionId | undefined;
    scope?: RedisKeyScope | undefined;
};
export type KeyRequest = {
    key: string;
    /** Optional transaction id */
    transactionId?: TransactionId | undefined;
    scope?: RedisKeyScope | undefined;
};
export type IncrByRequest = {
    key: string;
    value: number;
    /** Optional transaction id */
    transactionId?: TransactionId | undefined;
    scope?: RedisKeyScope | undefined;
};
export type SetRequest = {
    key: string;
    value: string;
    /** Expiration time in seconds */
    expiration: number;
    /** Set only if key does not exist */
    nx: boolean;
    /** Set only if key already exists */
    xx: boolean;
    /** Optional transaction id */
    transactionId?: TransactionId | undefined;
    scope?: RedisKeyScope | undefined;
};
export type KeyRangeRequest = {
    key: string;
    start: number;
    end: number;
    /** Optional transaction id */
    transactionId?: TransactionId | undefined;
    scope?: RedisKeyScope | undefined;
};
export type SetRangeRequest = {
    key: string;
    offset: number;
    value: string;
    /** Optional transaction id */
    transactionId?: TransactionId | undefined;
    scope?: RedisKeyScope | undefined;
};
export type KeysRequest = {
    keys: string[];
    /** Optional transaction id */
    transactionId?: TransactionId | undefined;
    scope?: RedisKeyScope | undefined;
};
export type KeysResponse = {
    keys: string[];
};
export type ExistsResponse = {
    existingKeys: number;
};
export type HGetRequest = {
    key: string;
    field: string;
    /** Optional transaction id */
    transactionId?: TransactionId | undefined;
    scope?: RedisKeyScope | undefined;
};
export type HMGetRequest = {
    key: string;
    fields: string[];
    /** Optional transaction id */
    transactionId?: TransactionId | undefined;
    scope?: RedisKeyScope | undefined;
};
export type HSetRequest = {
    key: string;
    fv: RedisFieldValue[];
    /** Optional transaction id */
    transactionId?: TransactionId | undefined;
    scope?: RedisKeyScope | undefined;
};
export type HSetNXResponse = {
    success: number;
};
export type HDelRequest = {
    key: string;
    fields: string[];
    /** Optional transaction id */
    transactionId?: TransactionId | undefined;
    scope?: RedisKeyScope | undefined;
};
export type HScanRequest = {
    key: string;
    cursor: number;
    pattern?: string | undefined;
    count?: number | undefined;
    /** Optional transaction id */
    transactionId?: TransactionId | undefined;
    scope?: RedisKeyScope | undefined;
};
export type HScanResponse = {
    cursor: number;
    fieldValues: RedisFieldValue[];
};
export type HIncrByRequest = {
    key: string;
    field: string;
    value: number;
    /** Optional transaction id */
    transactionId?: TransactionId | undefined;
    scope?: RedisKeyScope | undefined;
};
export type RedisFieldValue = {
    field: string;
    value: string;
};
export type RedisFieldValues = {
    fieldValues: {
        [key: string]: string;
    };
};
export type RedisFieldValues_FieldValuesEntry = {
    key: string;
    value: string;
};
export type KeyValuesRequest = {
    kv: RedisKeyValue[];
    /** Optional transaction id */
    transactionId?: TransactionId | undefined;
    scope?: RedisKeyScope | undefined;
};
export type RedisKeyValue = {
    key: string;
    value: string;
};
export type RedisValues = {
    values: string[];
};
export type ExpireRequest = {
    key: string;
    seconds: number;
    /** Optional transaction id */
    transactionId?: TransactionId | undefined;
    scope?: RedisKeyScope | undefined;
};
export type ZAddRequest = {
    key: string;
    members: ZMember[];
    /** Optional transaction id */
    transactionId?: TransactionId | undefined;
    scope?: RedisKeyScope | undefined;
};
export type ZScanRequest = {
    key: string;
    cursor: number;
    pattern?: string | undefined;
    count?: number | undefined;
    /** Optional transaction id */
    transactionId?: TransactionId | undefined;
    scope?: RedisKeyScope | undefined;
};
export type ZScanResponse = {
    cursor: number;
    members: ZMember[];
};
export type ZMembers = {
    members: ZMember[];
};
export type ZMember = {
    score: number;
    member: string;
};
export type TransactionId = {
    id: string;
};
export type WatchRequest = {
    transactionId?: TransactionId | undefined;
    keys: string[];
};
export type BitfieldRequest = {
    key: string;
    commands: BitfieldCommand[];
    /** Optional transaction id */
    transactionId?: TransactionId | undefined;
    scope?: RedisKeyScope | undefined;
};
export type BitfieldCommand = {
    get?: BitfieldGet | undefined;
    set?: BitfieldSet | undefined;
    incrBy?: BitfieldIncrBy | undefined;
    overflow?: BitfieldOverflow | undefined;
};
export type BitfieldGet = {
    encoding: string;
    offset: string;
};
export type BitfieldSet = {
    encoding: string;
    offset: string;
    value: string;
};
export type BitfieldIncrBy = {
    encoding: string;
    offset: string;
    increment: string;
};
export type BitfieldOverflow = {
    behavior: BitfieldOverflowBehavior;
};
export type BitfieldResponse = {
    results: number[];
};
export type HSetNXRequest = {
    key: string;
    field: string;
    value: string;
    /** Optional transaction id */
    transactionId?: TransactionId | undefined;
    scope?: RedisKeyScope | undefined;
};
export type RenameRequest = {
    key: string;
    newKey: string;
    scope?: RedisKeyScope | undefined;
};
export type RenameResponse = {
    result: string;
};
//# sourceMappingURL=redisapi.d.ts.map