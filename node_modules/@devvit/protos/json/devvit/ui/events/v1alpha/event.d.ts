/**
 * #event.ts
 *
 * Code generated by ts-proto. DO NOT EDIT.
 * @packageDocumentation
 */
import type { ConsentStatusEvent } from "../../effect_types/v1alpha/app_permission.js";
import type { OrderResultEvent } from "../../effect_types/v1alpha/create_order.js";
import type { FormCanceledEvent, FormSubmittedEvent } from "../../effect_types/v1alpha/show_form.js";
import type { ToastActionEvent } from "../../effect_types/v1alpha/show_toast.js";
import type { RealtimeSubscriptionEvent } from "../../effects/v1alpha/realtime_subscriptions.js";
import type { WebViewEvent } from "./web_view.js";
/**
 * This is set when we want to map events to a specific runtime, examples:
 * [1] incoming realtime messages on a websocket connection
 * [2] keydown events in a text input block
 * Both are intended to be run only on local runtime
 */
export declare enum UIEventScope {
    ALL = 0,
    LOCAL = 1,
    REMOTE = 2,
    UNRECOGNIZED = -1
}
/**
 * Blocks events. Don't add Webbit events here.
 *
 * @deprecated
 */
export type UIEvent = {
    realtimeEvent?: RealtimeSubscriptionEvent | undefined;
    formSubmitted?: FormSubmittedEvent | undefined;
    orderResult?: OrderResultEvent | undefined;
    toastAction?: ToastActionEvent | undefined;
    userAction?: UserAction | undefined;
    asyncRequest?: AsyncRequest | undefined;
    asyncResponse?: AsyncResponse | undefined;
    timer?: TimerEvent | undefined;
    blocking?: BlockingRenderEvent | undefined;
    resize?: ResizeEvent | undefined;
    webView?: WebViewEvent | undefined;
    formCanceled?: FormCanceledEvent | undefined;
    consentStatus?: ConsentStatusEvent | undefined;
    /**
     * If an event is async, it can be fired in parallel with other events.  Async events
     * are not allowed to mutate state.  Any state mutations they attempt would be ignored.
     * If they want to communicate something back to the state, they need to pass a message via
     * effects.
     */
    async?: boolean | undefined;
    /** The id of a the hook that should respond to this event */
    hook?: string | undefined;
    /** Signals if this event should be sent to the front (true) or back of the queue (false) */
    retry?: boolean | undefined;
    scope?: UIEventScope | undefined;
};
/**
 * Server-side rendering event.  This is a signal to the server that it should
 * wait for all of the promises to resolve before sending the response.
 *
 * The default behavior is to send the response as soon as possible, and then
 * stream in the rest of the data as it becomes available.  This is usually
 * slower on first load, but faster on subsequent loads.
 *
 * On first load, the server is usually close to the database, so the
 * back-and-forth is relatively cheap compared to asking the client to initiate
 * a bunch of waterfalling requests to the server.
 */
export type BlockingRenderEvent = {};
/** Signals to the server of device/client-side surface size changes */
export type ResizeEvent = {};
/**
 * There's no data sent with the timer (yet?).  Just knowing to fire it is
 * enough.
 */
export type TimerEvent = {};
export type AsyncError = {
    message: string;
    /** Typically a stack trace */
    details: string;
};
export type AsyncRequest = {
    requestId: string;
    data?: {
        [key: string]: any;
    } | undefined;
};
export type AsyncResponse = {
    requestId: string;
    data?: {
        [key: string]: any;
    } | undefined;
    error?: AsyncError | undefined;
};
export type UserAction = {
    actionId: string;
    data?: {
        [key: string]: any;
    } | undefined;
};
//# sourceMappingURL=event.d.ts.map