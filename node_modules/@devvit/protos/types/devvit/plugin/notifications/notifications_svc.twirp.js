import { TwirpServer, TwirpError, TwirpErrorCode, TwirpContentType, chainInterceptors, } from 'twirp-ts';
import { Empty } from '../../../google/protobuf/empty.js';
import { OptInCurrentUserResponse, OptOutCurrentUserResponse, ListOptedInUsersRequest, ListOptedInUsersResponse, IsOptedInRequest, IsOptedInResponse, } from './optin_msg.js';
import { EnqueueRequest, EnqueueResponse } from './pushnotif_msg.js';
import { ShowGamesDrawerBadgeRequest, ShowGamesDrawerBadgeResponse, DismissGamesDrawerBadgeRequest, DismissGamesDrawerBadgeResponse, GetGamesDrawerBadgeStatusRequest, GetGamesDrawerBadgeStatusResponse, } from './gamesdrawerbadge_msg.js';
export var NotificationsMethod;
(function (NotificationsMethod) {
    NotificationsMethod["OptInCurrentUser"] = "OptInCurrentUser";
    NotificationsMethod["OptOutCurrentUser"] = "OptOutCurrentUser";
    NotificationsMethod["ListOptedInUsers"] = "ListOptedInUsers";
    NotificationsMethod["IsOptedIn"] = "IsOptedIn";
    NotificationsMethod["Enqueue"] = "Enqueue";
    NotificationsMethod["ShowGamesDrawerBadge"] = "ShowGamesDrawerBadge";
    NotificationsMethod["DismissGamesDrawerBadge"] = "DismissGamesDrawerBadge";
    NotificationsMethod["GetGamesDrawerBadgeStatus"] = "GetGamesDrawerBadgeStatus";
})(NotificationsMethod || (NotificationsMethod = {}));
export const NotificationsMethodList = [
    NotificationsMethod.OptInCurrentUser,
    NotificationsMethod.OptOutCurrentUser,
    NotificationsMethod.ListOptedInUsers,
    NotificationsMethod.IsOptedIn,
    NotificationsMethod.Enqueue,
    NotificationsMethod.ShowGamesDrawerBadge,
    NotificationsMethod.DismissGamesDrawerBadge,
    NotificationsMethod.GetGamesDrawerBadgeStatus,
];
export function createNotificationsServer(service) {
    return new TwirpServer({
        service,
        packageName: 'devvit.plugin.notifications',
        serviceName: 'Notifications',
        methodList: NotificationsMethodList,
        matchRoute: matchNotificationsRoute,
    });
}
function matchNotificationsRoute(method, events) {
    switch (method) {
        case 'OptInCurrentUser':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'OptInCurrentUser' };
                await events.onMatch(ctx);
                return handleNotificationsOptInCurrentUserRequest(ctx, service, data, interceptors);
            };
        case 'OptOutCurrentUser':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'OptOutCurrentUser' };
                await events.onMatch(ctx);
                return handleNotificationsOptOutCurrentUserRequest(ctx, service, data, interceptors);
            };
        case 'ListOptedInUsers':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'ListOptedInUsers' };
                await events.onMatch(ctx);
                return handleNotificationsListOptedInUsersRequest(ctx, service, data, interceptors);
            };
        case 'IsOptedIn':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'IsOptedIn' };
                await events.onMatch(ctx);
                return handleNotificationsIsOptedInRequest(ctx, service, data, interceptors);
            };
        case 'Enqueue':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'Enqueue' };
                await events.onMatch(ctx);
                return handleNotificationsEnqueueRequest(ctx, service, data, interceptors);
            };
        case 'ShowGamesDrawerBadge':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'ShowGamesDrawerBadge' };
                await events.onMatch(ctx);
                return handleNotificationsShowGamesDrawerBadgeRequest(ctx, service, data, interceptors);
            };
        case 'DismissGamesDrawerBadge':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'DismissGamesDrawerBadge' };
                await events.onMatch(ctx);
                return handleNotificationsDismissGamesDrawerBadgeRequest(ctx, service, data, interceptors);
            };
        case 'GetGamesDrawerBadgeStatus':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'GetGamesDrawerBadgeStatus' };
                await events.onMatch(ctx);
                return handleNotificationsGetGamesDrawerBadgeStatusRequest(ctx, service, data, interceptors);
            };
        default:
            events.onNotFound();
            const msg = `no handler found`;
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleNotificationsOptInCurrentUserRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleNotificationsOptInCurrentUserJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleNotificationsOptInCurrentUserProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleNotificationsOptOutCurrentUserRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleNotificationsOptOutCurrentUserJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleNotificationsOptOutCurrentUserProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleNotificationsListOptedInUsersRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleNotificationsListOptedInUsersJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleNotificationsListOptedInUsersProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleNotificationsIsOptedInRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleNotificationsIsOptedInJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleNotificationsIsOptedInProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleNotificationsEnqueueRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleNotificationsEnqueueJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleNotificationsEnqueueProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleNotificationsShowGamesDrawerBadgeRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleNotificationsShowGamesDrawerBadgeJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleNotificationsShowGamesDrawerBadgeProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleNotificationsDismissGamesDrawerBadgeRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleNotificationsDismissGamesDrawerBadgeJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleNotificationsDismissGamesDrawerBadgeProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleNotificationsGetGamesDrawerBadgeStatusRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleNotificationsGetGamesDrawerBadgeStatusJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleNotificationsGetGamesDrawerBadgeStatusProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
async function handleNotificationsOptInCurrentUserJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = Empty.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.OptInCurrentUser(ctx, inputReq);
        });
    }
    else {
        response = await service.OptInCurrentUser(ctx, request);
    }
    return JSON.stringify(OptInCurrentUserResponse.toJSON(response));
}
async function handleNotificationsOptOutCurrentUserJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = Empty.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.OptOutCurrentUser(ctx, inputReq);
        });
    }
    else {
        response = await service.OptOutCurrentUser(ctx, request);
    }
    return JSON.stringify(OptOutCurrentUserResponse.toJSON(response));
}
async function handleNotificationsListOptedInUsersJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = ListOptedInUsersRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.ListOptedInUsers(ctx, inputReq);
        });
    }
    else {
        response = await service.ListOptedInUsers(ctx, request);
    }
    return JSON.stringify(ListOptedInUsersResponse.toJSON(response));
}
async function handleNotificationsIsOptedInJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = IsOptedInRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.IsOptedIn(ctx, inputReq);
        });
    }
    else {
        response = await service.IsOptedIn(ctx, request);
    }
    return JSON.stringify(IsOptedInResponse.toJSON(response));
}
async function handleNotificationsEnqueueJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = EnqueueRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Enqueue(ctx, inputReq);
        });
    }
    else {
        response = await service.Enqueue(ctx, request);
    }
    return JSON.stringify(EnqueueResponse.toJSON(response));
}
async function handleNotificationsShowGamesDrawerBadgeJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = ShowGamesDrawerBadgeRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.ShowGamesDrawerBadge(ctx, inputReq);
        });
    }
    else {
        response = await service.ShowGamesDrawerBadge(ctx, request);
    }
    return JSON.stringify(ShowGamesDrawerBadgeResponse.toJSON(response));
}
async function handleNotificationsDismissGamesDrawerBadgeJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = DismissGamesDrawerBadgeRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.DismissGamesDrawerBadge(ctx, inputReq);
        });
    }
    else {
        response = await service.DismissGamesDrawerBadge(ctx, request);
    }
    return JSON.stringify(DismissGamesDrawerBadgeResponse.toJSON(response));
}
async function handleNotificationsGetGamesDrawerBadgeStatusJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = GetGamesDrawerBadgeStatusRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetGamesDrawerBadgeStatus(ctx, inputReq);
        });
    }
    else {
        response = await service.GetGamesDrawerBadgeStatus(ctx, request);
    }
    return JSON.stringify(GetGamesDrawerBadgeStatusResponse.toJSON(response));
}
async function handleNotificationsOptInCurrentUserProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = Empty.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.OptInCurrentUser(ctx, inputReq);
        });
    }
    else {
        response = await service.OptInCurrentUser(ctx, request);
    }
    return Buffer.from(OptInCurrentUserResponse.encode(response).finish());
}
async function handleNotificationsOptOutCurrentUserProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = Empty.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.OptOutCurrentUser(ctx, inputReq);
        });
    }
    else {
        response = await service.OptOutCurrentUser(ctx, request);
    }
    return Buffer.from(OptOutCurrentUserResponse.encode(response).finish());
}
async function handleNotificationsListOptedInUsersProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = ListOptedInUsersRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.ListOptedInUsers(ctx, inputReq);
        });
    }
    else {
        response = await service.ListOptedInUsers(ctx, request);
    }
    return Buffer.from(ListOptedInUsersResponse.encode(response).finish());
}
async function handleNotificationsIsOptedInProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = IsOptedInRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.IsOptedIn(ctx, inputReq);
        });
    }
    else {
        response = await service.IsOptedIn(ctx, request);
    }
    return Buffer.from(IsOptedInResponse.encode(response).finish());
}
async function handleNotificationsEnqueueProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = EnqueueRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Enqueue(ctx, inputReq);
        });
    }
    else {
        response = await service.Enqueue(ctx, request);
    }
    return Buffer.from(EnqueueResponse.encode(response).finish());
}
async function handleNotificationsShowGamesDrawerBadgeProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = ShowGamesDrawerBadgeRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.ShowGamesDrawerBadge(ctx, inputReq);
        });
    }
    else {
        response = await service.ShowGamesDrawerBadge(ctx, request);
    }
    return Buffer.from(ShowGamesDrawerBadgeResponse.encode(response).finish());
}
async function handleNotificationsDismissGamesDrawerBadgeProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = DismissGamesDrawerBadgeRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.DismissGamesDrawerBadge(ctx, inputReq);
        });
    }
    else {
        response = await service.DismissGamesDrawerBadge(ctx, request);
    }
    return Buffer.from(DismissGamesDrawerBadgeResponse.encode(response).finish());
}
async function handleNotificationsGetGamesDrawerBadgeStatusProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = GetGamesDrawerBadgeStatusRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetGamesDrawerBadgeStatus(ctx, inputReq);
        });
    }
    else {
        response = await service.GetGamesDrawerBadgeStatus(ctx, request);
    }
    return Buffer.from(GetGamesDrawerBadgeStatusResponse.encode(response).finish());
}
