/**
 * #app.ts
 *
 * Code generated by ts-proto. DO NOT EDIT.
 * @packageDocumentation
 */
import _m0 from "protobufjs/minimal.js";
import { AppPromoStatus } from "../../../reddit/devvit/ads/v1/ads.js";
import { AppVersionInfo, ComputePool } from "../app_version/info/app_version_info.js";
import { FetchDomain } from "../fetch_domain/fetch_domain.js";
import { FetchDomainRequestInfo } from "../fetch_domain_request/fetch_domain_request.js";
import { Redditor } from "../reddit/redditor.js";
import { Categories } from "./categories/categories.js";
import { AppInfo } from "./info/app_info.js";
export declare enum OrderBy {
    DATE_CREATED = 0,
    NAME = 1,
    POPULARITY = 2,
    UNRECOGNIZED = -1
}
export declare function orderByFromJSON(object: any): OrderBy;
export declare function orderByToJSON(object: OrderBy): number;
/** Used to search for app(s). */
export interface AppSearchRequest {
    /**
     * What word(s) are you searching for? (NOTE: This feature is not yet
     * implemented.)
     */
    searchTerm?: string | undefined;
    /**
     * What categor(y|ies) does the app fit into?
     *
     * @deprecated
     */
    categories: Categories[];
    /** What page of results do you want? Defaults to the first page. */
    page?: number | undefined;
    /** What is the maximum number of items on a page? Defaults to 20. */
    pageSize?: number | undefined;
    /**
     * What field would you like to order the results by? Defaults to
     * DATE_CREATED.
     */
    orderBy: OrderBy;
    /** Would you like your results sorted in ascending order? Defaults to false. */
    isAscending?: boolean | undefined;
    /** Used with categoriesV2 */
    categoryIds: number[];
    /** Filter to apps owned by this user ID (t2_ format, eg 't2_abc123'). */
    ownerId?: string | undefined;
}
/** Used to get an app by its slug. */
export interface GetAppBySlugRequest {
    /** What is the slug of the app? */
    slug: string;
    /** How many versions of the app, at most, should we return? */
    limit?: number | undefined;
    /** How many versions of the app should we skip? (Useful for pagination!) */
    offset?: number | undefined;
    /** Should we hide prerelease versions? */
    hidePrereleaseVersions?: boolean | undefined;
}
export interface GetAllWithOwnerRequest {
    /**
     * Who's the owner in question? (Can be a t2_ ID or a username, with or
     * without `u/`)
     */
    owner: string;
    /** Maximum number of apps to return */
    take?: number | undefined;
    /** Number of apps to skip (for pagination) */
    skip?: number | undefined;
}
/** Used to create a new app. */
export interface AppCreationRequest {
    /** What is the new app's name? */
    name: string;
    /** What is the description of the app? */
    description: string;
    /** Is the app NSFW? NOTE: Once set, this cannot be reversed! */
    isNsfw: boolean;
    /**
     * What categor(y|ies) are you looking in?
     *
     * @deprecated
     */
    categories: Categories[];
    /**
     * Should we autogenerate a unique suffix for the app account?
     *
     * @deprecated
     */
    autogenerateName: boolean;
    /** What's the captcha verification code? */
    captcha: string;
    /** Used with categoriesV2 */
    categoryIds: number[];
}
/**
 * Used to get the X most popular apps, as determined by number of
 * installations.
 */
export interface GetPopularAppsRequest {
    /** How many apps should we return? */
    limit: number;
}
/** Contains the filename, size, and hash info for a piece of media. */
export interface MediaSignature {
    /**
     * Path to the file. This isn't saved in the system; it's primary use is so
     * that when we're telling the client later which pieces of media we do and do
     * not have already, it knows which files we're talking about easily.
     */
    filePath: string;
    /** Size of the file, in bytes */
    size: number;
    /** sha256 checksum of the file, as a hex string */
    hash: string;
    /** True if the asset is for webviews */
    isWebviewAsset: boolean;
}
/** Does the app already have any media uploaded that matches these signatures? */
export interface CheckIfMediaExistsRequest {
    id?: string | undefined;
    slug?: string | undefined;
    /** The signatures we want to look for */
    signatures: MediaSignature[];
}
/** Please upload this piece of media for this app. */
export interface UploadNewMediaRequest {
    id?: string | undefined;
    slug?: string | undefined;
    /**
     * The size of the media asset, in bytes. This will be validated, and an error
     * thrown if incorrect.
     */
    size: number;
    /**
     * The sha256 hash of the media asset, as a hex string. This will be
     * validated, and an error thrown if incorrect.
     */
    hash: string;
    /** The contents of the file. */
    contents: Uint8Array;
    /**
     * Make this asset available for webview consumption _instead_ of app UI
     * consumption.
     */
    webviewAsset?: boolean | undefined;
    /** The path of the file in the project assets. Necessary for webview assets. */
    filePath?: string | undefined;
}
/**
 * Used to update an existing app's information.
 * If a field is optional, omitting it will leave its value unchanged.
 */
export interface AppUpdateRequest {
    /** What is the ID of the app you're trying to update? */
    id: string;
    /** What is the app's new slug? */
    slug?: string | undefined;
    /** What's the app's new name? */
    name?: string | undefined;
    /** What's the app's new description? */
    description?: string | undefined;
    /** Is the app NSFW? NOTE: Once set, this cannot be reversed! */
    isNsfw?: boolean | undefined;
    /** Is the app delisted? (This is only editable by admins.) */
    isDelisted?: boolean | undefined;
    /**
     * What categor(y|ies) does the app belong in?
     *
     * @deprecated
     */
    categories: Categories[];
    /** What are the terms and conditions of using this app? */
    termsAndConditions?: string | undefined;
    /** What is the privacy policy this app? */
    privacyPolicy?: string | undefined;
    /** What is the default compute pool that new versions should be assigned? */
    defaultPool?: ComputePool | undefined;
    /**
     * Is the app allowed to use the webview block and manage webview assets?
     * Deprecated: Use capabilities instead.
     * TODO: remove this after 2 releases. sometime in (Q4 2024)
     *
     * @deprecated
     */
    isWebviewEnabled?: boolean | undefined;
    /**
     * Is the app installation in small subreddits restricted (the actual limit is
     * specified in the code)
     */
    minSubredditSizeRestrictionEnabled?: boolean | undefined;
    /**
     * The promotion status of the app, for ads team use to mark
     * promoted apps and what level they are promoted.
     */
    promoStatus?: AppPromoStatus | undefined;
    /** Used with categoriesV2 */
    categoryIds: number[];
    /**
     * Is the app archived? (only app owners and admins can archive an app)
     * This field acts as a "soft delete" or deprecation status for an app:
     * - hides from search results
     * - prevents new installs (by anyone but the app owner)
     */
    isArchived?: boolean | undefined;
}
/**
 * Contains the basic information about an app, as well as all versions of the
 * app, and any statistics about the app that we want to include.
 */
export interface FullAppInfo {
    app?: AppInfo | undefined;
    versions: AppVersionInfo[];
    fetchDomainRequests: FetchDomainRequestInfo[];
}
/** Represents information about an app and its domain info, including domain requests and allowed domains. */
export interface AppWithDomainInfo {
    /** The ID of the app, eg '6d0a383a-eb60-44ed-92c5-62b6261177f8' */
    appId: string;
    /** The slug of the app, eg 'wsb-app' */
    appSlug: string;
    /** The name of the app, eg 'WSB App' */
    appName: string;
    /** The account of the app owner, eg 't2_3c4d' */
    appOwnerAccount?: Redditor | undefined;
    /** The list of fetch domain requests for the app. */
    domainRequests: FetchDomainRequestInfo[];
    /** The list of allowed domains for the app. */
    allowedDomains: FetchDomain[];
}
/** Request used to get an app by its slug with its domain info. */
export interface GetAppBySlugWithDomainInfoRequest {
    /** The slug of app, eg 'pixelary-game' */
    appSlug: string;
}
/** Request used to get a list of apps with their domain info. */
export interface GetAppsWithDomainInfoRequest {
    /** How many apps to return in a single page. */
    pageSize: number;
    /** The page number of apps to return. The page number should start at 1. */
    pageNumber: number;
}
/** Response containing a list of apps with their domain info. */
export interface GetAppsWithDomainInfoResponse {
    /** The list of apps with their domain info. */
    apps: AppWithDomainInfo[];
    /** Indicates whether or not there is a next page of apps. */
    hasNextPage?: boolean | undefined;
}
/** Request used to add many domains to an app's 'allowedDomains' list. */
export interface AddDomainsToAppRequest {
    /** The ID of the app to add the domains to, eg '6d0a383a-eb60-44ed-92c5-62b6261177f8' */
    appId: string;
    /** The domains to add to the app, eg 'hello-world.com', 'w3schools.org' */
    domains: string[];
}
/** Request used to remove a domain from an app's 'allowedDomains' list. */
export interface RemoveDomainFromAppRequest {
    /** The ID of the app to remove the domain from, eg '6d0a383a-eb60-44ed-92c5-62b6261177f8' */
    appId: string;
    /** The domain to remove from the app, eg 'hello-world.com' */
    domain: string;
}
/**
 * Contains the status of a piece of media - whether we've seen it before or
 * not.
 */
export interface MediaSignatureStatus {
    /** Path to the file, as was given in the request object */
    filePath: string;
    /** Is this file new to the app? */
    isNew: boolean;
    /** If the file isn't new, will contain the media ID of the existing asset. */
    existingMediaId?: string | undefined;
}
/** A list of the status of each media signature we were asked about. */
export interface CheckIfMediaExistsResponse {
    /**
     * The status of each requested media signature - whether we've seen it before
     * or not.
     */
    statuses: MediaSignatureStatus[];
}
/** The response given when a new piece of media is uploaded. */
export interface UploadNewMediaResponse {
    /** The ID of the asset as saved in the developer portal. */
    assetId: string;
    /** The ID of the media as given by the media service. */
    mediaId: string;
}
/** The results of searching for an app */
export interface AppSearchResponse {
    /** This page's apps; there may be more on other pages */
    apps: AppInfo[];
    /** How many total results exist for this search */
    totalResults: number;
    /** What page number this is */
    pageNumber: number;
    /** The maximum number of items on each page */
    pageSize: number;
}
export interface AppExistsRequest {
    /** Does an app with this slug exist? */
    slug?: string | undefined;
}
export interface AppExistsResponse {
    exists: boolean;
}
export interface AppAccountExistsRequest {
    /** The name of the app account (without the leading u/) */
    accountName: string;
}
export interface AppAccountExistsResponse {
    exists: boolean;
    suggestions: string[];
}
export interface CreateAppAccountRequest {
    slug: string;
    accountName?: string | undefined;
    captcha: string;
}
export interface CreateAppAccountResponse {
    created: boolean;
    errors?: string | undefined;
}
/** Used to recover partially created apps. */
export interface RecoverAppAccountRequest {
    /** What is the new app's name? */
    name: string;
    /** What is the slug/identifier of the app? */
    slug: string;
    /** What is the description of the app? */
    description: string;
    /** Is the app NSFW? NOTE: Once set, this cannot be reversed! */
    isNsfw: boolean;
    /**
     * What categor(y|ies) does the app fit into?
     *
     * @deprecated
     */
    categories: Categories[];
    /** What is the ID of the owner of the app? */
    ownerId: string;
    /** What is the username of the app account to recover? */
    username: string;
    /** What is the temporary password of the app account to recover? */
    password: string;
    /** Used with categoriesV2 */
    categoryIds: number[];
}
export interface DisableAppRequest {
    /** App UUID */
    id: string;
}
export interface EnableAppRequest {
    /** App UUID */
    id: string;
}
export declare const AppSearchRequest: {
    $type: "devvit.dev_portal.app.AppSearchRequest";
    encode(message: AppSearchRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): AppSearchRequest;
    fromJSON(object: any): AppSearchRequest;
    toJSON(message: AppSearchRequest): unknown;
    create(base?: DeepPartial<AppSearchRequest>): AppSearchRequest;
    fromPartial(object: DeepPartial<AppSearchRequest>): AppSearchRequest;
};
export declare const GetAppBySlugRequest: {
    $type: "devvit.dev_portal.app.GetAppBySlugRequest";
    encode(message: GetAppBySlugRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): GetAppBySlugRequest;
    fromJSON(object: any): GetAppBySlugRequest;
    toJSON(message: GetAppBySlugRequest): unknown;
    create(base?: DeepPartial<GetAppBySlugRequest>): GetAppBySlugRequest;
    fromPartial(object: DeepPartial<GetAppBySlugRequest>): GetAppBySlugRequest;
};
export declare const GetAllWithOwnerRequest: {
    $type: "devvit.dev_portal.app.GetAllWithOwnerRequest";
    encode(message: GetAllWithOwnerRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): GetAllWithOwnerRequest;
    fromJSON(object: any): GetAllWithOwnerRequest;
    toJSON(message: GetAllWithOwnerRequest): unknown;
    create(base?: DeepPartial<GetAllWithOwnerRequest>): GetAllWithOwnerRequest;
    fromPartial(object: DeepPartial<GetAllWithOwnerRequest>): GetAllWithOwnerRequest;
};
export declare const AppCreationRequest: {
    $type: "devvit.dev_portal.app.AppCreationRequest";
    encode(message: AppCreationRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): AppCreationRequest;
    fromJSON(object: any): AppCreationRequest;
    toJSON(message: AppCreationRequest): unknown;
    create(base?: DeepPartial<AppCreationRequest>): AppCreationRequest;
    fromPartial(object: DeepPartial<AppCreationRequest>): AppCreationRequest;
};
export declare const GetPopularAppsRequest: {
    $type: "devvit.dev_portal.app.GetPopularAppsRequest";
    encode(message: GetPopularAppsRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): GetPopularAppsRequest;
    fromJSON(object: any): GetPopularAppsRequest;
    toJSON(message: GetPopularAppsRequest): unknown;
    create(base?: DeepPartial<GetPopularAppsRequest>): GetPopularAppsRequest;
    fromPartial(object: DeepPartial<GetPopularAppsRequest>): GetPopularAppsRequest;
};
export declare const MediaSignature: {
    $type: "devvit.dev_portal.app.MediaSignature";
    encode(message: MediaSignature, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MediaSignature;
    fromJSON(object: any): MediaSignature;
    toJSON(message: MediaSignature): unknown;
    create(base?: DeepPartial<MediaSignature>): MediaSignature;
    fromPartial(object: DeepPartial<MediaSignature>): MediaSignature;
};
export declare const CheckIfMediaExistsRequest: {
    $type: "devvit.dev_portal.app.CheckIfMediaExistsRequest";
    encode(message: CheckIfMediaExistsRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): CheckIfMediaExistsRequest;
    fromJSON(object: any): CheckIfMediaExistsRequest;
    toJSON(message: CheckIfMediaExistsRequest): unknown;
    create(base?: DeepPartial<CheckIfMediaExistsRequest>): CheckIfMediaExistsRequest;
    fromPartial(object: DeepPartial<CheckIfMediaExistsRequest>): CheckIfMediaExistsRequest;
};
export declare const UploadNewMediaRequest: {
    $type: "devvit.dev_portal.app.UploadNewMediaRequest";
    encode(message: UploadNewMediaRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): UploadNewMediaRequest;
    fromJSON(object: any): UploadNewMediaRequest;
    toJSON(message: UploadNewMediaRequest): unknown;
    create(base?: DeepPartial<UploadNewMediaRequest>): UploadNewMediaRequest;
    fromPartial(object: DeepPartial<UploadNewMediaRequest>): UploadNewMediaRequest;
};
export declare const AppUpdateRequest: {
    $type: "devvit.dev_portal.app.AppUpdateRequest";
    encode(message: AppUpdateRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): AppUpdateRequest;
    fromJSON(object: any): AppUpdateRequest;
    toJSON(message: AppUpdateRequest): unknown;
    create(base?: DeepPartial<AppUpdateRequest>): AppUpdateRequest;
    fromPartial(object: DeepPartial<AppUpdateRequest>): AppUpdateRequest;
};
export declare const FullAppInfo: {
    $type: "devvit.dev_portal.app.FullAppInfo";
    encode(message: FullAppInfo, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): FullAppInfo;
    fromJSON(object: any): FullAppInfo;
    toJSON(message: FullAppInfo): unknown;
    create(base?: DeepPartial<FullAppInfo>): FullAppInfo;
    fromPartial(object: DeepPartial<FullAppInfo>): FullAppInfo;
};
export declare const AppWithDomainInfo: {
    $type: "devvit.dev_portal.app.AppWithDomainInfo";
    encode(message: AppWithDomainInfo, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): AppWithDomainInfo;
    fromJSON(object: any): AppWithDomainInfo;
    toJSON(message: AppWithDomainInfo): unknown;
    create(base?: DeepPartial<AppWithDomainInfo>): AppWithDomainInfo;
    fromPartial(object: DeepPartial<AppWithDomainInfo>): AppWithDomainInfo;
};
export declare const GetAppBySlugWithDomainInfoRequest: {
    $type: "devvit.dev_portal.app.GetAppBySlugWithDomainInfoRequest";
    encode(message: GetAppBySlugWithDomainInfoRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): GetAppBySlugWithDomainInfoRequest;
    fromJSON(object: any): GetAppBySlugWithDomainInfoRequest;
    toJSON(message: GetAppBySlugWithDomainInfoRequest): unknown;
    create(base?: DeepPartial<GetAppBySlugWithDomainInfoRequest>): GetAppBySlugWithDomainInfoRequest;
    fromPartial(object: DeepPartial<GetAppBySlugWithDomainInfoRequest>): GetAppBySlugWithDomainInfoRequest;
};
export declare const GetAppsWithDomainInfoRequest: {
    $type: "devvit.dev_portal.app.GetAppsWithDomainInfoRequest";
    encode(message: GetAppsWithDomainInfoRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): GetAppsWithDomainInfoRequest;
    fromJSON(object: any): GetAppsWithDomainInfoRequest;
    toJSON(message: GetAppsWithDomainInfoRequest): unknown;
    create(base?: DeepPartial<GetAppsWithDomainInfoRequest>): GetAppsWithDomainInfoRequest;
    fromPartial(object: DeepPartial<GetAppsWithDomainInfoRequest>): GetAppsWithDomainInfoRequest;
};
export declare const GetAppsWithDomainInfoResponse: {
    $type: "devvit.dev_portal.app.GetAppsWithDomainInfoResponse";
    encode(message: GetAppsWithDomainInfoResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): GetAppsWithDomainInfoResponse;
    fromJSON(object: any): GetAppsWithDomainInfoResponse;
    toJSON(message: GetAppsWithDomainInfoResponse): unknown;
    create(base?: DeepPartial<GetAppsWithDomainInfoResponse>): GetAppsWithDomainInfoResponse;
    fromPartial(object: DeepPartial<GetAppsWithDomainInfoResponse>): GetAppsWithDomainInfoResponse;
};
export declare const AddDomainsToAppRequest: {
    $type: "devvit.dev_portal.app.AddDomainsToAppRequest";
    encode(message: AddDomainsToAppRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): AddDomainsToAppRequest;
    fromJSON(object: any): AddDomainsToAppRequest;
    toJSON(message: AddDomainsToAppRequest): unknown;
    create(base?: DeepPartial<AddDomainsToAppRequest>): AddDomainsToAppRequest;
    fromPartial(object: DeepPartial<AddDomainsToAppRequest>): AddDomainsToAppRequest;
};
export declare const RemoveDomainFromAppRequest: {
    $type: "devvit.dev_portal.app.RemoveDomainFromAppRequest";
    encode(message: RemoveDomainFromAppRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): RemoveDomainFromAppRequest;
    fromJSON(object: any): RemoveDomainFromAppRequest;
    toJSON(message: RemoveDomainFromAppRequest): unknown;
    create(base?: DeepPartial<RemoveDomainFromAppRequest>): RemoveDomainFromAppRequest;
    fromPartial(object: DeepPartial<RemoveDomainFromAppRequest>): RemoveDomainFromAppRequest;
};
export declare const MediaSignatureStatus: {
    $type: "devvit.dev_portal.app.MediaSignatureStatus";
    encode(message: MediaSignatureStatus, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MediaSignatureStatus;
    fromJSON(object: any): MediaSignatureStatus;
    toJSON(message: MediaSignatureStatus): unknown;
    create(base?: DeepPartial<MediaSignatureStatus>): MediaSignatureStatus;
    fromPartial(object: DeepPartial<MediaSignatureStatus>): MediaSignatureStatus;
};
export declare const CheckIfMediaExistsResponse: {
    $type: "devvit.dev_portal.app.CheckIfMediaExistsResponse";
    encode(message: CheckIfMediaExistsResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): CheckIfMediaExistsResponse;
    fromJSON(object: any): CheckIfMediaExistsResponse;
    toJSON(message: CheckIfMediaExistsResponse): unknown;
    create(base?: DeepPartial<CheckIfMediaExistsResponse>): CheckIfMediaExistsResponse;
    fromPartial(object: DeepPartial<CheckIfMediaExistsResponse>): CheckIfMediaExistsResponse;
};
export declare const UploadNewMediaResponse: {
    $type: "devvit.dev_portal.app.UploadNewMediaResponse";
    encode(message: UploadNewMediaResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): UploadNewMediaResponse;
    fromJSON(object: any): UploadNewMediaResponse;
    toJSON(message: UploadNewMediaResponse): unknown;
    create(base?: DeepPartial<UploadNewMediaResponse>): UploadNewMediaResponse;
    fromPartial(object: DeepPartial<UploadNewMediaResponse>): UploadNewMediaResponse;
};
export declare const AppSearchResponse: {
    $type: "devvit.dev_portal.app.AppSearchResponse";
    encode(message: AppSearchResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): AppSearchResponse;
    fromJSON(object: any): AppSearchResponse;
    toJSON(message: AppSearchResponse): unknown;
    create(base?: DeepPartial<AppSearchResponse>): AppSearchResponse;
    fromPartial(object: DeepPartial<AppSearchResponse>): AppSearchResponse;
};
export declare const AppExistsRequest: {
    $type: "devvit.dev_portal.app.AppExistsRequest";
    encode(message: AppExistsRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): AppExistsRequest;
    fromJSON(object: any): AppExistsRequest;
    toJSON(message: AppExistsRequest): unknown;
    create(base?: DeepPartial<AppExistsRequest>): AppExistsRequest;
    fromPartial(object: DeepPartial<AppExistsRequest>): AppExistsRequest;
};
export declare const AppExistsResponse: {
    $type: "devvit.dev_portal.app.AppExistsResponse";
    encode(message: AppExistsResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): AppExistsResponse;
    fromJSON(object: any): AppExistsResponse;
    toJSON(message: AppExistsResponse): unknown;
    create(base?: DeepPartial<AppExistsResponse>): AppExistsResponse;
    fromPartial(object: DeepPartial<AppExistsResponse>): AppExistsResponse;
};
export declare const AppAccountExistsRequest: {
    $type: "devvit.dev_portal.app.AppAccountExistsRequest";
    encode(message: AppAccountExistsRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): AppAccountExistsRequest;
    fromJSON(object: any): AppAccountExistsRequest;
    toJSON(message: AppAccountExistsRequest): unknown;
    create(base?: DeepPartial<AppAccountExistsRequest>): AppAccountExistsRequest;
    fromPartial(object: DeepPartial<AppAccountExistsRequest>): AppAccountExistsRequest;
};
export declare const AppAccountExistsResponse: {
    $type: "devvit.dev_portal.app.AppAccountExistsResponse";
    encode(message: AppAccountExistsResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): AppAccountExistsResponse;
    fromJSON(object: any): AppAccountExistsResponse;
    toJSON(message: AppAccountExistsResponse): unknown;
    create(base?: DeepPartial<AppAccountExistsResponse>): AppAccountExistsResponse;
    fromPartial(object: DeepPartial<AppAccountExistsResponse>): AppAccountExistsResponse;
};
export declare const CreateAppAccountRequest: {
    $type: "devvit.dev_portal.app.CreateAppAccountRequest";
    encode(message: CreateAppAccountRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): CreateAppAccountRequest;
    fromJSON(object: any): CreateAppAccountRequest;
    toJSON(message: CreateAppAccountRequest): unknown;
    create(base?: DeepPartial<CreateAppAccountRequest>): CreateAppAccountRequest;
    fromPartial(object: DeepPartial<CreateAppAccountRequest>): CreateAppAccountRequest;
};
export declare const CreateAppAccountResponse: {
    $type: "devvit.dev_portal.app.CreateAppAccountResponse";
    encode(message: CreateAppAccountResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): CreateAppAccountResponse;
    fromJSON(object: any): CreateAppAccountResponse;
    toJSON(message: CreateAppAccountResponse): unknown;
    create(base?: DeepPartial<CreateAppAccountResponse>): CreateAppAccountResponse;
    fromPartial(object: DeepPartial<CreateAppAccountResponse>): CreateAppAccountResponse;
};
export declare const RecoverAppAccountRequest: {
    $type: "devvit.dev_portal.app.RecoverAppAccountRequest";
    encode(message: RecoverAppAccountRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): RecoverAppAccountRequest;
    fromJSON(object: any): RecoverAppAccountRequest;
    toJSON(message: RecoverAppAccountRequest): unknown;
    create(base?: DeepPartial<RecoverAppAccountRequest>): RecoverAppAccountRequest;
    fromPartial(object: DeepPartial<RecoverAppAccountRequest>): RecoverAppAccountRequest;
};
export declare const DisableAppRequest: {
    $type: "devvit.dev_portal.app.DisableAppRequest";
    encode(message: DisableAppRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): DisableAppRequest;
    fromJSON(object: any): DisableAppRequest;
    toJSON(message: DisableAppRequest): unknown;
    create(base?: DeepPartial<DisableAppRequest>): DisableAppRequest;
    fromPartial(object: DeepPartial<DisableAppRequest>): DisableAppRequest;
};
export declare const EnableAppRequest: {
    $type: "devvit.dev_portal.app.EnableAppRequest";
    encode(message: EnableAppRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EnableAppRequest;
    fromJSON(object: any): EnableAppRequest;
    toJSON(message: EnableAppRequest): unknown;
    create(base?: DeepPartial<EnableAppRequest>): EnableAppRequest;
    fromPartial(object: DeepPartial<EnableAppRequest>): EnableAppRequest;
};
type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;
type DeepPartial<T> = T extends Builtin ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
export {};
//# sourceMappingURL=app.d.ts.map