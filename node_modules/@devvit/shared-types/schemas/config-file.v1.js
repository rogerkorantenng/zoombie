/**
 * Warning: this file is not isomorphic. Do not functionally import this file
 * from client code.
 */
import { readFileSync } from 'node:fs';
import { Scope } from '@devvit/protos/json/reddit/devvit/app_permission/v1/app_permission.js';
import jsonschema, {} from 'jsonschema/lib/index.js';
import schema from './config-file.v1.json' with { type: 'json' };
import { defaultPostEntry, UNINITIALIZED_APP_NAME } from './constants.js';
import productsSchema from './products.json' with { type: 'json' };
import { validateProductsJSON } from './productsSchemaJSONValidator.js';
export function parseAppConfig(str, allowUninitializedConfig) {
    if (!str)
        throw Error('config is empty');
    let json;
    try {
        json = JSON.parse(str);
    }
    catch (err) {
        throw Error(`cannot parse config JSON`, { cause: err });
    }
    return parseAppConfigJson(json, allowUninitializedConfig);
}
export function parseAppConfigJson(json, allowUninitializedConfig) {
    const uninitializedSchema = {
        ...schema,
        properties: {
            ...schema.properties,
            name: {
                ...schema.properties.name,
                pattern: `${schema.properties.name.pattern}|^${UNINITIALIZED_APP_NAME}$`,
            },
        },
    };
    const devvitSchema = (allowUninitializedConfig
        ? uninitializedSchema
        : schema);
    const validator = new jsonschema.Validator();
    validator.addSchema(devvitSchema, schema.$id);
    validator.addSchema(productsSchema, productsSchema.$id);
    const ret = validator.validate(json, devvitSchema);
    if (!ret.valid)
        throw new Error(ret.errors
            .map((err) => {
            if (!err.path.length && err.name === 'anyOf' && /\[subschema \d]/.test(err.stack))
                return 'config requires property "post", "server", or "blocks".';
            if (err.stack.includes('name does not match pattern'))
                return err.stack
                    .replaceAll('instance.', '')
                    .concat('. Try running `npx devvit init` to fix your app name.');
            return err.stack.replaceAll('instance.', '').replaceAll('instance', 'config');
        })
            .join('; '));
    const instance = ret.instance;
    if (instance.$schema != null && instance.$schema !== schema.$id)
        console.warn(`Unknown schema "${instance.$schema}".`);
    return AppConfig(instance);
}
// jsonschema only supports rewrite hooks but it's easier to update defaults
// after validation when the entire config is known. Eg,
// `config.permissions.http` has a different default if `config.server` is set.
//
// Ajv supports some default application but it seems like some features are
// still missing (https://github.com/ajv-validator/ajv/issues/1158). Even if the
// feature is added, we need the defaults in the properties for documentation
// and the same dynamic default adjustments as above are required.
//
// If there's an explicit permission, use it. If the permission is inferred, add
// a Blocks permission config that defaults to true to avoid having to evaluate
// user Blocks code. Model hydration should consider Blocks permissions.
//
// The current pattern is to avoid being smart about item / entry lengths. If a
// user defines a config, hydrate it regardless of whether any members are
// provided. This is so that Blocks apps can use the same hydrated models.
function AppConfig(json) {
    const partial = {
        schema: 'v1', // Always assume v1 since that's all that's supported.
        name: json.name,
        json,
    };
    if (json.media)
        partial.media = {
            dir: json.media.dir ?? schema.properties.media.properties.dir.default,
        };
    if (json.post)
        partial.post = AppPostConfig(json.post);
    if (json.server)
        partial.server = {
            dir: json.server.dir ?? schema.properties.server.properties.dir.default,
            entry: json.server.entry ?? schema.properties.server.properties.entry.default,
        };
    const blocksTriggers = json.blocks
        ? (json.blocks.triggers ?? schema.properties.blocks.properties.triggers.default)
        : undefined;
    if (json.triggers || blocksTriggers)
        partial.triggers = AppTriggersConfig(blocksTriggers, json.triggers);
    if (json.blocks)
        partial.blocks = AppBlocksConfig(json.blocks);
    const blocksMenu = json.blocks
        ? (json.blocks.menu?.enable ??
            schema.properties.blocks.properties.menu.properties.enable.default)
        : false;
    if (json.menu || blocksMenu)
        partial.menu = AppMenuConfig(json.menu);
    if (json.payments)
        partial.payments = AppPaymentsConfig(json.payments);
    if (json.scheduler)
        partial.scheduler = AppSchedulerConfig(json.scheduler);
    const blocksSettings = json.blocks
        ? (json.blocks.settings?.enable ??
            schema.properties.blocks.properties.settings.properties.enable.default)
        : false;
    if (json.settings || blocksSettings)
        partial.settings = AppSettingsConfig(blocksSettings, json.settings);
    const blocksForms = json.blocks
        ? (json.blocks.forms?.enable ??
            schema.properties.blocks.properties.forms.properties.enable.default)
        : false;
    if (json.forms || blocksForms)
        partial.forms = json.forms ?? {};
    if (json.marketingAssets)
        partial.marketingAssets = json.marketingAssets;
    if (json.dev) {
        partial.dev = {};
        if (json.dev.subreddit)
            partial.dev.subreddit = json.dev.subreddit;
    }
    if (json.scripts) {
        partial.scripts = json.scripts;
    }
    const config = { ...partial, permissions: AppPermissionConfig(json.permissions, partial) };
    validate(config);
    // Deep copy so schema is not mutated.
    return structuredClone(config);
}
function AppSchedulerConfig(scheduler) {
    const config = { tasks: {} };
    for (const [name, taskSpec] of Object.entries(scheduler.tasks)) {
        if (typeof taskSpec === 'string') {
            // If the task is a string, it is an endpoint.
            config.tasks[name] = { endpoint: taskSpec };
        }
        else {
            // Otherwise, it is an object with an endpoint and optionally a cron.
            config.tasks[name] = {
                endpoint: taskSpec.endpoint,
                ...(taskSpec.cron
                    ? { cron: taskSpec.cron, ...(taskSpec.data ? { data: taskSpec.data } : {}) }
                    : {}),
            };
        }
    }
    return config;
}
function AppPermissionConfig(permissions, partial) {
    const redditPermissions = typeof permissions?.reddit === 'boolean' ? { enable: permissions.reddit } : permissions?.reddit;
    return {
        http: {
            enable: permissions?.http?.enable ??
                (permissions?.http
                    ? schema.properties.permissions.properties.http.properties.enable.default
                    : false),
            domains: permissions?.http?.domains ??
                schema.properties.permissions.properties.http.properties.domains.default,
        },
        media: permissions?.media ?? schema.properties.permissions.properties.media.default,
        menu: !!partial.menu,
        payments: !!partial.payments ||
            (permissions?.payments ?? schema.properties.permissions.properties.payments.default),
        realtime: permissions?.realtime ?? schema.properties.permissions.properties.realtime.default,
        redis: permissions?.redis ??
            // Menu items call addCSRFTokenToContext() which uses Redis.
            (partial.menu
                ? true
                : partial.post
                    ? true
                    : schema.properties.permissions.properties.redis.default),
        reddit: {
            enable: redditPermissions?.enable ??
                (partial.post
                    ? true
                    : redditPermissions
                        ? schema.properties.permissions.properties.reddit.oneOf[0].properties.enable.default
                        : false),
            scope: redditPermissions?.scope ??
                schema.properties.permissions.properties.reddit.oneOf[0].properties.scope
                    .default,
            asUser: redditPermissions?.asUser?.map((x) => scopeFromJSON(x)) ??
                schema.properties.permissions.properties.reddit.oneOf[0].properties.asUser.default,
        },
        settings: !!partial.settings,
        triggers: !!partial.triggers,
    };
}
function AppPostConfig(post) {
    const dir = post.dir ?? schema.properties.post.properties.dir.default;
    const defaultHeight = schema.$defs.Entrypoint.properties.height.default;
    const entrypoints = {
        [defaultPostEntry]: {
            name: defaultPostEntry,
            entry: post.entrypoints?.default.entry ??
                schema.properties.post.properties.entrypoints.properties.default.properties.entry.default,
            height: post.entrypoints?.default.height ?? defaultHeight,
            inline: post.entrypoints?.default.inline ?? false,
        },
    };
    for (const [name, pt] of Object.entries(post.entrypoints ?? {})) {
        if (name !== defaultPostEntry)
            entrypoints[name] = {
                name,
                entry: pt.entry,
                height: pt.height ?? defaultHeight,
                inline: pt.inline ?? false,
            };
    }
    return { dir, entrypoints };
}
function AppBlocksConfig(blocks) {
    return {
        entry: blocks.entry ?? schema.properties.blocks.properties.entry.default,
    };
}
function AppMenuConfig(menu) {
    const items = [];
    for (const item of menu?.items ?? []) {
        items.push({
            label: item.label,
            description: item.description ?? '',
            forUserType: item.forUserType ?? 'moderator',
            postFilter: item.postFilter ?? 'none',
            location: Array.isArray(item.location) ? item.location : [item.location],
            endpoint: item.endpoint,
        });
    }
    return { items };
}
function AppPaymentsConfig(payments) {
    if (!payments) {
        throw Error(`Invalid false-y payments config`);
    }
    if (!payments.endpoints?.fulfillOrder) {
        throw Error(`Order fulfillment endpoint is required`);
    }
    const rawProducts = 'products' in payments ? [...payments.products] : [];
    if ('productsFile' in payments) {
        const fileContents = readFileSync(payments.productsFile).toString();
        rawProducts.push(...validateProductsJSON(JSON.parse(fileContents)));
    }
    console.log(`Loaded ${rawProducts.length} products from payments config.`);
    const products = [];
    for (const rawProduct of rawProducts) {
        const product = {
            accountingType: rawProduct.accountingType,
            displayName: rawProduct.displayName,
            price: rawProduct.price,
            sku: rawProduct.sku,
        };
        if (rawProduct.metadata) {
            // Shallow copy to make sure any further mutations don't affect the config.
            product.metadata = {
                ...rawProduct.metadata,
            };
        }
        if (rawProduct.images) {
            product.images = rawProduct.images;
        }
        if (rawProduct.description) {
            product.description = rawProduct.description;
        }
        products.push(product);
    }
    return {
        endpoints: payments.endpoints,
        products,
        ...('productsFile' in payments ? { productsFile: payments.productsFile } : {}),
    };
}
function AppSettingsConfig(blocksSettings, settings) {
    const config = {};
    if (settings?.global || blocksSettings) {
        config.global = {};
        for (const [name, setting] of Object.entries(settings?.global ?? {})) {
            config.global[name] = { ...setting, name: name };
        }
    }
    if (settings?.subreddit || blocksSettings) {
        config.subreddit = {};
        for (const [name, setting] of Object.entries(settings?.subreddit ?? {})) {
            config.subreddit[name] = { ...setting, name: name };
        }
    }
    return config;
}
function AppTriggersConfig(blocksTriggers, triggers) {
    const config = {};
    for (const trigger of blocksTriggers ?? [])
        config[trigger] = '';
    return { ...config, ...triggers };
}
/** @internal */
export function validate(config) {
    const errs = [];
    if (config.menu?.items?.length && !config.permissions.redis)
        errs.push('`config.menu.items` requires `config.permissions.redis` to be enabled');
    // If there are any select settings, their default values must be in the options,
    // and if it's not a multi-select, the default value must be a single string.
    const settingValues = [
        ...Object.values(config.settings?.global ?? {}),
        ...Object.values(config.settings?.subreddit ?? {}),
    ];
    for (const setting of settingValues) {
        if (setting.type === 'select' && setting.defaultValue) {
            if (!setting.options.some((option) => option.value === setting.defaultValue))
                errs.push(`Setting "${setting.name}" default value "${setting.defaultValue}" is not in
          options "${setting.options.map((option) => option.value).join(', ')}"`);
        }
        if (setting.type === 'multiSelect' && setting.defaultValue) {
            if (!setting.defaultValue.every((value) => setting.options.some((option) => option.value === value)))
                errs.push(`Setting "${setting.name}" default values "${setting.defaultValue.join(', ')}" are not in options "${setting.options.map((option) => option.value).join(', ')}"`);
        }
    }
    if (errs.length)
        throw Error(`${errs.join('; ')}.`);
}
function scopeFromJSON(scope) {
    return scope in Scope ? Scope[scope] : Scope.UNRECOGNIZED;
}
